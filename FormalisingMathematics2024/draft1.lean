import Mathlib.Tactic
import Mathlib.RingTheory.UniqueFactorizationDomain
import Mathlib.RingTheory.PrincipalIdealDomain
import Mathlib.Data.MvPolynomial.CommRing
import Mathlib.RingTheory.Polynomial.Basic
import Mathlib.Data.MvPolynomial.Basic
import Mathlib.Analysis.Convex.SimplicialComplex.Basic

open MvPolynomial Classical
namespace ProjectThree
variable {X K : Type} [CommSemiring K]

/-- An abstract simplicial complex is a collection of finite sets which is downward closed with
respect to set inclusion. -/
structure AbstractSimplicialComplex (X : Type) where
  faces : Set (Finset X)
  empty_mem : ∅ ∈ faces
  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ∈ faces

instance : Membership (Finset X) (AbstractSimplicialComplex X) :=
  ⟨fun f Δ => f ∈ Δ.faces⟩

/-- A multivariate polynomial `m` is a squarefree monomial if `m` has a single term with exponents
all 1 or 0. e.g `m = xyz`. -/
def isSqFreeMonomial (m : MvPolynomial X K) : Prop :=
  ∃ f, support m ⊆ {f} ∧ ∀ x : X, f x = 0 ∨ f x = 1

/-- A squarefree monomial ideal is the ideal generated by a collection of squarefree monomials. -/
structure SqFreeMonomialIdeal (X K : Type) [CommSemiring K] where
  basis : Set (MvPolynomial X K)
  ideal : Ideal (MvPolynomial X K)
  ideal_eq_span : ideal = Ideal.span basis
  sq_free : ∀ m, m ∈ basis → isSqFreeMonomial m

instance : Membership (MvPolynomial X K) (SqFreeMonomialIdeal X K) :=
  ⟨fun m I => m ∈ I.ideal⟩

@[simp]
theorem mem_ideal (m : MvPolynomial X K) (I : SqFreeMonomialIdeal X K) : m ∈ I ↔ m ∈ I.ideal :=
  Iff.rfl

/-- `SqFreeMonomialIdeal` is upwards closed with respect to division. -/
lemma mono_ideal_up_closed (I : SqFreeMonomialIdeal X K) (m m' : MvPolynomial X K) (h : m ∣ m')
    (hm : m ∈ I) : m' ∈ I := by
  obtain ⟨r, hr⟩ := h
  rw [mem_ideal] at hm ⊢
  simpa [hr] using (Ideal.mul_mem_right r I.ideal hm)

/-- Index for a squarefree monomial. `A` is the Finset describing which varibales to include.
E.g if `A = {1, 2, 3} ⊂ ℕ = X` then `s A` is the indicator function on `A`. It corresponds to
the monomial `xy²z³`. -/
noncomputable def s (A : Finset X) : X →₀ ℕ where
  support := A
  toFun := fun x ↦ if x ∈ A then 1 else 0
  mem_support_toFun := by
    intro a
    constructor
    <;> intro h
    · simpa [ne_eq, ite_eq_right_iff, one_ne_zero, imp_false, not_not]
    · by_contra h'
      have : (fun x ↦ if x ∈ A then 1 else 0) a = 0
      · simpa only [ite_eq_right_iff, one_ne_zero, imp_false]
      contradiction

/- Some lemmas about the Finsupp `s A`. -/

@[simp]
lemma s_eq_toFun (A : Finset X) : s A = (s A).toFun := by rfl
lemma s_to_fun_eq_fun (A : Finset X) : (s A).toFun = fun w ↦ if w ∈ A then 1 else 0 := by rfl
lemma s_eq_one_iff (A : Finset X) (x : X) : (s A) x = 1 ↔ x ∈ A := by
  simp_all only [s_eq_toFun, s_to_fun_eq_fun, ite_eq_left_iff, zero_ne_one, imp_false, not_not]
lemma s_eq_zero_iff (A : Finset X) (x : X) : (s A) x = 0 ↔ x ∉ A := by
  simp_all only [s_eq_toFun, s_to_fun_eq_fun, ite_eq_right_iff, one_ne_zero, imp_false]
lemma s_eq_zero_or_one (A : Finset X) (x : X) : (s A) x = 0 ∨ (s A) x = 1 := by
  simp_rw [s_eq_one_iff, s_eq_zero_iff]
  exact em' (x ∈ A)

/- The next two definitions describe how we can go from monomials to sets and sets to monomials. -/

/-- The monomial supported by a Finset `A` is the monomial with exponents described by the elements
of `A` and coefficient 1. -/
noncomputable def monomialSupportedByFinset (K : Type) (A : Finset X) [CommSemiring K] :
  MvPolynomial X K := monomial (s A) 1

/-- Given a monomial, we can construct a set based upon the varibales included in the monomial. -/
noncomputable def suppOfMonomial (m : MvPolynomial X K) (h : isSqFreeMonomial m) : Finset X := by
  obtain ⟨-, -⟩ := choose_spec h
  exact if support m = {choose h} then (choose h).support else Finset.empty

/-- The monomial supported by a set is square free. -/
lemma mono_supp_is_sq_free (A : Finset X) : isSqFreeMonomial (monomialSupportedByFinset K A) := by
  use s A
  constructor
  · exact support_monomial_subset
  · intro x
    exact s_eq_zero_or_one A x

@[simp]
lemma monomialSupportedByFinset_def (K : Type) (A : Finset X) [CommSemiring K] :
    monomialSupportedByFinset K A = monomial (s A) 1 := by rfl

#check monomial_eq_monomial_iff
#check monic_monomial_eq
#check monomial_eq
#check coeff
lemma prop22a (m : MvPolynomial X K) (hsq : isSqFreeMonomial m) :
    monomialSupportedByFinset K (suppOfMonomial m hsq) = m := by
  dsimp only [monomialSupportedByFinset_def]
  ext q



  sorry

lemma prop22b (A : Finset X) : suppOfMonomial (monomialSupportedByFinset K A)
    (mono_supp_is_sq_free A) = A := by
  sorry

lemma prop22c (m m' : MvPolynomial X K) (hm : isSqFreeMonomial m) (hm' : isSqFreeMonomial m') :
    m ∣ m' ↔ suppOfMonomial m hm ⊆ suppOfMonomial m' hm' := by
  constructor
  <;> intro h
  · sorry
  · sorry

def stanleyReisnerComplex (I : SqFreeMonomialIdeal X K) : AbstractSimplicialComplex X where
  faces := {suppOfMonomial m _ | isSqFreeMonomial m ∧ m ∉ I}
  empty_mem := _
  down_closed := _


#check GaloisConnection
theorem galois_connection_ASC_monomial : GaloisConnection suppOfMonomial monomialSupportedByFinset := by sorry

end ProjectThree

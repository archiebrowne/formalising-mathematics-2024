import Mathlib.Tactic
import Mathlib.Topology.Filter
import Mathlib.Order.Filter.Basic
import Mathlib.Topology.Compactness.Compact
import Mathlib.Order.Zorn

open Filter Set
open scoped Filter Topology


variable {ι X : Type} {π : ι → Type} {H : Set X}
variable [∀ i, TopologicalSpace (π i)] [TopologicalSpace X]

/- In a Lattice, there is a notion of 'Atomic' elements. These are elements
with no elements between it and `⊥`. A Lattice `IsAtomic` if every element
has an atom bellow it. `Filter X` forms a Lattice, and since we can show that
an `Atom` is infact an ultrafilter, it is enough to show `IsAtomic (Filter X)`.
After this, we can unfold this in the context of Filters, and this is what we
do in `MyExists_le`, giving the usual interpretation of the ultrafilter lemma. -/

-- Credit to Kevin who got me to type the line:

#synth IsAtomic (Filter X)

-- which pointed me in the correct direction.

/-- The lattice of filters on `X` is Atomic. -/
instance isAtomic_filter : IsAtomic (Filter X) := by
/- The orderind on filters is counterintuetive, if `f ≤ g` then
this means that `g.sets ⊆ f.sets`. For this reason we need a version of
Zorn's lemma which works for finding a 'least element'. i.e an ultrafilters
are 'small' with respect to `≤`. -/
  apply IsAtomic.of_isChain_bounded
  intro c hc hne hcnbot
/- We want to provide a lower bound on the chain `c` which is not `⊥`.
`sInf c` is the union of all of the filters in `c` and is the correct choice. -/
  use sInf c
/- We must prove that `sInf c` is not `⊥` and also that it is a lower bound
for `c`. -/
  constructor
  · intro U hU
/- Trivially, any element of `c` is greater than the infimum. -/
    exact sInf_le hU
  · rw [← neBot_iff]
/- The `sInf` of a set is not equal to `⊥` if the set is nonempty, the
partial order `≤` is 'directed' on the set, and `⊥` is not in the set.
'directed' means that for any pair of elements in the set, we can find a third
`≥` both. If the set were not directed, then the `sInf` may well be `⊥`.
consider for instance the case where `c` is the collection of
all principal filters generated by points in `X`. Then the smallest filter
(w.r.t `≤`) 'less' than all of them is the power set of `X`. i.e `⊥`. -/
    refine sInf_neBot_of_directed' hne ?_ hcnbot
/- It turns out that chains do indeed have this directed property since for any
`x y` in a chain we have `x ≤ y` or `y ≤ x`. So the maximum of `x y` is bigger than both. -/
    apply IsChain.directedOn
/- `hc` says that `c` is a chain, so the rest of the proof is just giving lean this information. -/
    intro F hF G hG hFG
    specialize hc hF hG hFG
    simp_rw [ge_iff_le] at hc ⊢
    exact Or.comm.mpr hc

/-- **The Ultrafilter Lemma** Any filter on `X` not equal to `⊥` is extensible to an ultrafilter. -/
theorem MyExists_le (f : Filter X) [h : NeBot f] : ∃ u : Ultrafilter X, ↑u ≤ f := by
/- In an atomic lattice, every emelent is either `⊥` or has an atom bellow it. -/
  cases' IsAtomic.eq_bot_or_exists_atom_le f with h1 h2
/- We have `h : NeBot f` so it is absurd that `f = ⊥`. -/
  · rw [neBot_iff] at h
    contradiction
/- `f` has an atom bellow it, and any atom is infact an ultrafilter. This is a pretty
simple check, and provided by `Ultrafilter.ofAtom`. This is the correct ultrafilter to
use for the claim. -/
  · obtain ⟨a, ha, haf⟩ := h2
    use (Ultrafilter.ofAtom a ha)
    exact haf
